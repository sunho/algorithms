/**************************************************************
# 문제 설명 
 문제2)
n×n 바둑판 모양으로 총 n2개의 방이 있다. 일부분은 검은 방이고 나머지는 모두 흰 방이다. 검은 방은 사면이 벽으로 싸여 있어 들어가 수 없다. 서로 붙어 있는 두 개의 흰 방 사이에는 문이 있어서 지나다닐 수 있다. 윗줄 맨 왼쪽 방은 시작방으로서 항상 흰 방이고, 아랫줄 맨 오른쪽 방은 끝방으로서 역시 흰 방이다.
시작방에서 출발하여 길을 찾아서 끝방으로 가는 것이 목적인데, 아래 그림의 경우에는 시작방에서 끝 방으로 갈 수가 없다. 부득이 검은 방 몇 개를 흰 방으로 바꾸어야 하는데 되도록 적은 수의 방의 색을 바꾸고 싶다.
아래 그림은 n=8인 경우의 한 예이다.

위 그림에서는 두 개의 검은 방(예를 들어 (4,4)의 방과 (7,8)의 방)을 흰 방으로 바꾸면, 시작방에서 끝방으로 갈 수 있지만, 어느 검은 방 하나만을 흰 방으로 바꾸어서는 불가능하다. 검은 방에서 흰 방으로 바꾸어야 할 최소의 수를 구하는 프로그램을 작성하시오.
단, 검은 방을 하나도 흰방으로 바꾸지 않아도 되는 경우는 0이 답이다.
 
# 입력 
 첫 줄에는 한 줄에 들어가는 방의 수 n(1≤n≤50)이 주어지고,
다음 n개의 줄의 각 줄마다 0과 1이 이루어진 길이가 n인 수열이 주어진다.
0은 검은 방, 1은 흰 방을 나타낸다. 
# 출력 
 첫 줄에 흰 방으로 바꾸어야 할 최소의 검은 방의 수를 출력한다. 
# 입력 예시 
 8
11100110
11010010
10011010
11101100
01000111
00110001
11011000
11000111 
# 출력 예시 
 2 
# 도움말 
  
# 출처 
 1997 KOI 고등 

*************************************************************/
#include <iostream>

using namespace std;

bool visit[50][50];
int map[50][50];
int n;
int total;
bool quit;
void resetVisit()
{
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            visit[i][j]=false;
        }
    }
}
void printMap()
{
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(map[i][j]) cout<<"■";
            else cout<<"□";
        }
        cout<<endl;
    }
}
void removeBlock(int x,int y)
{
    if(visit[x][y]==0&&!quit&&
        x>=0&&x<n&&y>=0&&y<n)
    {
        visit[x][y]=1;
        if(x==n-1&&y==n-1)
        {
            cout<<total;
            quit=true;
        }
        if(map[x][y]==1)
        {
            map[x][y]=2;
        }
        if(map[x][y]==0)
        {
            removeBlock(x-1,y);
            removeBlock(x+1,y);
            removeBlock(x,y-1);
            removeBlock(x,y+1);
        }
    }
}
void removeOne()
{
    removeBlock(0,0);
    total++;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(map[i][j]==2)
            {
                map[i][j]=0;
            }
        }
    }
}
int main()
{
    cin>>n;
    char s[50];
    for(int i=0;i<n;i++)
    {
        cin>>s;
        for(int j=0;j<n;j++)
        {
            map[i][j]=!(s[j]-'0');
        }
    }
    while(!quit)
    {
        removeOne();
        resetVisit();
    }
}

/**************************************************************
	문제번호: 4438
	아이디: ksunhokim
	사용언어: C++
	결과: 정확한 풀이
	수행 시간:0 ms
	메모리 사용량:1708 kb
****************************************************************/

