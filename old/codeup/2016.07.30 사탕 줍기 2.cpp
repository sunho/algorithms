/**************************************************************
# 문제 설명 
 지원이는 사탕을 사기위해 새로 개업한 사탕가게에 갔다.
사탕가게 아저씨는 격자판에 사탕을 각각 담아 두고, 첫 손님 기념으로 다음과 같은 제안을 하였다.
"각 행과 열에 여러개의 사탕이 있는데, 각 행과 열이 겹치지 않게 사탕을 가져가라. "
즉, $1$행 $1$열을 선택했다면 $2$행 부터는 $1$열을 선택하지 못한다.
지원이는 머리를 써서 최대한 많은 수의 사탕을 가지고 싶어한다.
지원이가 가질 수 있는 최대 사탕수를 구하시오.
예)

    
        
            3
            1
            4
        
        
            2
            5
            4
        
        
            1
            4
            1
        
    

첫 행에 $3$, 둘째 행에 $4$, 셋째 행에 $4$를 선택하면 최대 사탕수는 $11$이 된다. 
# 입력 
 첫 행에 격자판의 크기 $N$이 입력된다.$(N<=10)$
둘째 행부터 $N+1$행까지 격자판의 정보인 사탕수가 입력된다.
 
# 출력 
 지원이가 가질 수 있는 최대 사탕수를 출력한다.
 
# 입력 예시 
 3
3 1 4
2 5 4
1 4 1 
# 출력 예시 
 11 
# 도움말 
  
# 출처 
  

*************************************************************/
#include <iostream>
#include <string.h>
using namespace std;
int n;
int maximum;
int arr[10][10]={0};
int* intcpy(int* arr)
{
    int* d=new int[10];
    for(int i=0;i<10;i++)
    {
        d[i]=arr[i];
    }
    return d;
}
void dfs(int i,int sum,int* d)
{
    if(i==n)
    {
        if(maximum<sum)
        {
            maximum=sum;
        }
        return;
    }
    for(int j=0;j<n;j++)
    {
        if(d[j]==0)
        {
            int* newD=intcpy(d);
            newD[j]=1;
            dfs(i+1,sum+arr[i][j],newD);
            delete newD;
        }
    }
}
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            cin>>arr[i][j];
        }
    }
    int* d=new int[10];
    memset(d,0,sizeof(int)*10);
    dfs(0,0,d);
    cout<<maximum;
}

/**************************************************************
	문제번호: 3515
	아이디: ksunhokim
	사용언어: C++
	결과: 정확한 풀이
	수행 시간:864 ms
	메모리 사용량:1696 kb
****************************************************************/

